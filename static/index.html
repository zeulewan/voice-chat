<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Voice Chat</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: #1a1a2e;
  color: #e0e0e0;
  height: 100vh;
  display: flex;
  flex-direction: column;
}
#header {
  padding: 0.75rem 1rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
  background: #16162a;
  border-bottom: 1px solid #2a2a4a;
}
#dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #e63946;
  transition: background 0.3s;
}
#dot.connected { background: #2ecc71; }
#conn-label {
  font-size: 0.8rem;
  color: #888;
}
#chat {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}
.msg {
  max-width: 80%;
  padding: 0.75rem 1rem;
  border-radius: 1rem;
  line-height: 1.5;
  font-size: 0.95rem;
}
.msg.user {
  align-self: flex-end;
  background: #3a86ff;
  color: #fff;
  border-bottom-right-radius: 0.25rem;
}
.msg.assistant {
  align-self: flex-start;
  background: #2a2a4a;
  border-bottom-left-radius: 0.25rem;
}
#controls {
  padding: 1rem;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  background: #16162a;
}
#status {
  font-size: 0.85rem;
  color: #888;
  min-height: 1.2em;
}
#mic {
  width: 72px;
  height: 72px;
  border-radius: 50%;
  border: none;
  background: #3a86ff;
  color: #fff;
  font-size: 1.8rem;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
}
#mic:hover { background: #2a76ef; }
#mic.recording {
  background: #e63946;
  animation: pulse 1s infinite;
}
#mic:disabled { opacity: 0.4; cursor: not-allowed; }
@keyframes pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(230,57,70,0.5); }
  50% { box-shadow: 0 0 0 12px rgba(230,57,70,0); }
}
</style>
</head>
<body>

<div id="header">
  <div id="dot"></div>
  <span id="conn-label">Disconnected</span>
</div>

<div id="chat"></div>

<div id="controls">
  <div id="status">Waiting for connection...</div>
  <button id="mic" disabled>&#127908;</button>
</div>

<script>
const chat = document.getElementById('chat');
const mic = document.getElementById('mic');
const status = document.getElementById('status');
const dot = document.getElementById('dot');
const connLabel = document.getElementById('conn-label');

let ws = null;
let mediaRecorder = null;
let audioChunks = [];
let recording = false;

function addMessage(role, text) {
  const div = document.createElement('div');
  div.className = `msg ${role}`;
  div.textContent = text;
  chat.appendChild(div);
  chat.scrollTop = chat.scrollHeight;
}

function setStatus(msg) {
  console.log('[status]', msg);
  status.textContent = msg;
}

function setConnected(connected) {
  dot.classList.toggle('connected', connected);
  connLabel.textContent = connected ? 'Connected' : 'Disconnected';
  if (!connected) {
    mic.disabled = true;
    setStatus('Waiting for connection...');
  }
}

// --- WebSocket ---

function connect() {
  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  const url = `${proto}//${location.host}/ws`;
  console.log('[ws] Connecting to', url);
  ws = new WebSocket(url);

  ws.onopen = () => {
    console.log('[ws] Connected');
    setConnected(true);
    setStatus('Connected — waiting for Claude (/voice-chat)');
    mic.disabled = false;
  };

  ws.onclose = (e) => {
    console.log('[ws] Closed:', e.code, e.reason);
    setConnected(false);
    ws = null;
    setTimeout(connect, 2000);
  };

  ws.onerror = (e) => {
    console.error('[ws] Error:', e);
    ws?.close();
  };

  ws.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log('[ws] Received:', data.type, data.type === 'audio' ? `(${data.data.length} chars)` : data.text || '');

    if (data.type === 'audio') {
      playAudio(data.data);
    } else if (data.type === 'listening') {
      startRecording();
    } else if (data.type === 'status') {
      setStatus(data.text);
    } else if (data.type === 'done') {
      setStatus('Ready');
      mic.disabled = false;
    }
  };
}

// --- Audio playback ---

function playAudio(b64data) {
  setStatus('Playing...');
  mic.disabled = true;
  const bytes = Uint8Array.from(atob(b64data), c => c.charCodeAt(0));
  const blob = new Blob([bytes], { type: 'audio/mpeg' });
  const url = URL.createObjectURL(blob);
  const audio = new Audio(url);

  audio.onended = () => {
    console.log('[audio] Playback ended, sending playback_done');
    URL.revokeObjectURL(url);
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'playback_done' }));
    }
  };

  audio.onerror = (e) => {
    console.error('[audio] Playback error:', e);
    URL.revokeObjectURL(url);
    setStatus('Audio playback error');
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'playback_done' }));
    }
  };

  audio.play().catch(e => {
    console.error('[audio] play() rejected:', e);
    setStatus('Audio play blocked — tap page first');
    if (ws && ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'playback_done' }));
    }
  });
}

// --- Recording ---

async function startRecording() {
  console.log('[mic] Starting recording...');
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm;codecs=opus' });
    audioChunks = [];
    mediaRecorder.ondataavailable = e => { if (e.data.size > 0) audioChunks.push(e.data); };
    mediaRecorder.onstop = () => {
      console.log('[mic] Recording stopped, chunks:', audioChunks.length);
      stream.getTracks().forEach(t => t.stop());
      sendAudio();
    };
    mediaRecorder.start();
    recording = true;
    mic.classList.add('recording');
    mic.disabled = false;
    setStatus('Recording... tap to stop');
  } catch (err) {
    console.error('[mic] getUserMedia error:', err);
    setStatus('Microphone access denied');
  }
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    console.log('[mic] Stopping recording...');
    mediaRecorder.stop();
  }
  recording = false;
  mic.classList.remove('recording');
}

function sendAudio() {
  if (!ws || ws.readyState !== WebSocket.OPEN) {
    console.error('[send] WebSocket not open, cannot send audio');
    setStatus('Not connected');
    return;
  }

  const blob = new Blob(audioChunks, { type: 'audio/webm' });
  console.log('[send] Reading audio blob:', blob.size, 'bytes');
  setStatus('Processing...');
  mic.disabled = true;

  const reader = new FileReader();
  reader.onload = () => {
    const b64 = reader.result.split(',')[1];
    console.log('[send] Sending audio:', b64.length, 'chars b64');
    ws.send(JSON.stringify({ type: 'audio', data: b64 }));
    console.log('[send] Audio sent, waiting for server response...');
  };
  reader.onerror = (e) => {
    console.error('[send] FileReader error:', e);
    setStatus('Error reading audio');
    mic.disabled = false;
  };
  reader.readAsDataURL(blob);
}

// --- Mic button: tap to toggle ---

mic.addEventListener('click', () => {
  if (mic.disabled) return;
  if (recording) {
    stopRecording();
  } else {
    startRecording();
  }
});

// Start connection
connect();
</script>
</body>
</html>
